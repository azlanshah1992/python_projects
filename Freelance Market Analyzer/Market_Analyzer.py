import tkinter as tk
from tkinter import filedialog, messagebox, ttk
import threading
import os
import requests
from bs4 import BeautifulSoup
import pandas as pd
import time
from requests.exceptions import RequestException
import re
from collections import Counter
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from matplotlib.backends.backend_pdf import PdfPages


# --- Core Logic Functions (Refactored from data_set.py and data_analysis_plotting.py) ---

def run_scraper(keyword, csv_filepath, update_status, NUM_PAGES, SLEEP_TIME=2):
    """Executes the web scraping logic and saves the raw data to CSV."""

    # Define the total allocation for scraping (60% of the progress bar)
    SCRAPING_ALLOCATION = 60
    percent_per_page = SCRAPING_ALLOCATION / NUM_PAGES

    # Headers mimic a browser request to avoid blocking
    REQUEST_HEADERS = {
        "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/126.0.0.0 Safari/537.36",
        "Accept-Language": "en-US,en;q=0.9",
        "Accept-Encoding": "gzip, deflate, br",
        "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8"
    }

    scraped_data = []

    for page in range(1, NUM_PAGES + 1):
        # Status update: Dynamic scraping progress calculation
        progress_val = page * percent_per_page
        update_status(f"Scraping Page {page}/{NUM_PAGES} for '{keyword}'...", progress_val)

        url = f"https://www.fiverr.com/search/gigs?query={keyword}&page={page}"

        try:
            r = requests.get(url, headers=REQUEST_HEADERS, timeout=10)
            r.raise_for_status()
        except RequestException as e:
            update_status(f"âŒ Error fetching page {page}. Skipping...", progress_val)
            print(f"Error: {e}")
            continue

        soup = BeautifulSoup(r.text, "html.parser")
        gigs = soup.find_all("div", {"class": "basic-gig-card"})

        if not gigs and page > 1:
            # Assume no more results
            update_status(f"Completed after {page - 1} pages (End of search results).", SCRAPING_ALLOCATION)
            break

        for gig in gigs:
            title_element = gig.find("p", {"class": "f2YMuU6 tbody-5 text-normal"})
            price_container = gig.find("span", {"class": "text-bold co-grey-1200"})
            seller_element = gig.find("span", {"data-track-tag": "typography"})

            title = title_element.text.strip() if title_element else None
            raw_price = price_container.text.strip() if price_container else None
            seller = seller_element.text.strip() if seller_element else "N/A"
            price = None

            if raw_price:
                # Clean price string
                price_numbers = re.findall(r'[\d,.]+', raw_price)
                price = "".join(price_numbers).strip()

            if title and price:
                scraped_data.append({"Title": title, "Price": price, "Seller": seller})

        time.sleep(SLEEP_TIME)

    # Convert to DataFrame, clean, and save
    df = pd.DataFrame(scraped_data)
    df_clean = df.drop_duplicates(subset=['Title', 'Seller'], keep='first')
    df_clean.to_csv(csv_filepath, index=False)

    # Final progress update for scraping phase
    update_status(f"Scraping finished. {len(df_clean)} unique gigs saved.", SCRAPING_ALLOCATION)
    return df_clean


def run_analyzer(keyword, csv_filepath, pdf_filepath, update_status):
    """Executes the data analysis and plotting logic, saving the report to PDF."""

    update_status("Loading data for analysis...", 65)  # Start analysis phase at 65%

    # Load the CSV file generated by the scraper
    try:
        df = pd.read_csv(csv_filepath)
    except FileNotFoundError:
        messagebox.showerror("Error", f"CSV file not found at {csv_filepath}")
        return False

    # --- Data Cleaning ---
    def clean_price(price_str):
        if pd.isna(price_str) or price_str == 'None':
            return np.nan
        price_numbers = re.findall(r'[\d,.]+', price_str)
        cleaned_price = "".join(price_numbers).replace(',', '')
        try:
            return float(cleaned_price)
        except ValueError:
            return np.nan

    df['Price'] = df['Price'].astype(str)
    df['Price_Numeric'] = df['Price'].apply(clean_price)
    df.dropna(subset=['Price_Numeric'], inplace=True)

    if df.empty:
        messagebox.showwarning("Warning", "No valid price data to analyze.")
        return False

    update_status("Cleaning data and extracting keywords...", 70)

    # --- Keyword Processing ---
    STOP_WORDS = set([
        keyword.lower(), 'your', 'will', 'and', 'with', 'the', 'project', 'projects', 'tasks',
        'script', 'scripts', 'program', 'coding', 'create', 'develop', 'using',
        'in', 'you', 'for', 'from', 'app', 'fix', 'make', 'build', 'any', 'website', 'saas',
        'mobile', 'software', 'developer', 'apps', 'web', 'business', 'application', 'data'
    ])

    all_keywords = df['Title'].str.findall(r'\b[a-zA-Z]{3,}\b').str.join(' ').str.lower()
    keywords_list = [word for title_words in all_keywords for word in title_words.split()
                     if word not in STOP_WORDS and len(word) > 2]

    common_keywords = Counter(keywords_list).most_common(20)
    kw_df = pd.DataFrame(common_keywords, columns=["Keyword", "Count"])

    # Set visual style
    sns.set_style("whitegrid")
    plt.rcParams['font.sans-serif'] = ['Segoe UI', 'Arial']

    # Filter price outliers for visualization
    max_price = df['Price_Numeric'].quantile(0.95)
    df_filtered_price = df[df['Price_Numeric'] <= max_price].copy()

    # --- Price Statistics ---
    price_stats = df_filtered_price['Price_Numeric'].describe()
    q1_price = price_stats['25%']
    median_price = price_stats['50%']
    q3_price = price_stats['75%']

    update_status("Generating 5 plots for PDF report...", 80)

    # --- PDF Generation and Visualization ---
    with PdfPages(pdf_filepath) as pdf:

        # 1. Keyword Demand
        plt.figure(figsize=(12, 8))
        sns.barplot(x="Count", y="Keyword", data=kw_df, palette="viridis", hue="Keyword", legend=False)
        plt.title(f"Top 20 Technical Keywords by Gig Volume for '{keyword}'", fontsize=16)
        plt.xlabel("Gig Frequency (Volume)", fontsize=12)
        plt.ylabel("")
        pdf.savefig()
        plt.close()

        # 2. Price Distribution (Histogram)
        plt.figure(figsize=(10, 6))
        sns.histplot(df_filtered_price['Price_Numeric'], bins=20, kde=True, color="darkorange")
        plt.title("Market Price Distribution (95% of Gigs)", fontsize=16)
        plt.xlabel("Price (Local Currency)", fontsize=12)
        plt.ylabel("Number of Gigs", fontsize=12)
        plt.axvline(median_price, color='red', linestyle='--', linewidth=2, label=f"Median: {median_price:,.0f}")
        plt.axvline(q1_price, color='blue', linestyle=':', linewidth=1, label=f"Q1 (25%): {q1_price:,.0f}")
        plt.axvline(q3_price, color='green', linestyle=':', linewidth=1, label=f"Q3 (75%): {q3_price:,.0f}")
        plt.legend()
        pdf.savefig()
        plt.close()

        # 3. Price Spread by Niche (Box Plot)
        top_N_keywords = kw_df['Keyword'].head(10).tolist()
        df['Niche_Keyword'] = df['Title'].apply(
            lambda title: next((k for k in top_N_keywords if k in title.lower()), 'Other'))
        df_niche_price = df[df['Niche_Keyword'] != 'Other']
        niche_counts = df_niche_price.groupby('Niche_Keyword').size()
        viable_niches = niche_counts[niche_counts >= 10].index
        df_niche_price = df_niche_price[df_niche_price['Niche_Keyword'].isin(viable_niches)].copy()
        price_cap_box = df_niche_price['Price_Numeric'].quantile(0.90)
        df_niche_price = df_niche_price[df_niche_price['Price_Numeric'] <= price_cap_box]

        plt.figure(figsize=(12, 7))
        sns.boxplot(x='Niche_Keyword', y='Price_Numeric', data=df_niche_price, palette='Set2',
                    order=viable_niches.tolist())
        plt.title("Price Distribution by Viable Niche (Top 10 Keywords)", fontsize=16)
        plt.xlabel(f"Keyword Niche (Min 10 Gigs)", fontsize=12)
        plt.ylabel("Price (Local Currency)", fontsize=12)
        pdf.savefig()
        plt.close()

        # 4. Competition (Unique Sellers per Niche)
        keyword_seller_counts = {}
        for kw in kw_df['Keyword'].head(10):
            gigs_with_keyword = df[df['Title'].str.contains(kw, case=False, na=False)]
            keyword_seller_counts[kw] = gigs_with_keyword['Seller'].nunique()

        competition_df = pd.DataFrame(list(keyword_seller_counts.items()),
                                      columns=['Keyword', 'Unique_Sellers']).sort_values(by='Unique_Sellers',
                                                                                         ascending=False)

        plt.figure(figsize=(12, 7))
        sns.barplot(x='Unique_Sellers', y='Keyword', data=competition_df, palette='PuRd')
        plt.title("Competition: Unique Sellers per Niche (Top 10 Keywords)", fontsize=16)
        plt.xlabel("Number of Unique Sellers", fontsize=12)
        plt.ylabel("")
        pdf.savefig()
        plt.close()

        # 5. Seller Productivity
        seller_counts = df.groupby('Seller')['Title'].count().sort_values(ascending=False).head(10)
        seller_df = seller_counts.reset_index(name='Gig_Count')

        plt.figure(figsize=(10, 6))
        sns.barplot(x="Gig_Count", y="Seller", data=seller_df, palette="crest")
        plt.title("Top 10 Sellers by Gig Volume", fontsize=16)
        plt.xlabel("Number of Unique Gigs", fontsize=12)
        plt.ylabel("")
        pdf.savefig()
        plt.close()

        update_status("PDF report successfully created.", 95)

    return True


# --- Tkinter GUI Application ---

class FiverrAnalyzerApp:
    def __init__(self, master):
        self.master = master
        master.title("Fiverr Market Analyzer")
        master.geometry("600x440")  # Increased size to fit new control

        # Status variables
        self.status_text = tk.StringVar(master, value="Ready to start analysis.")
        self.progress_value = tk.DoubleVar(master, value=0)

        # Default File Paths and Keyword
        default_dir = os.getcwd()
        self.search_keyword = tk.StringVar(master, value="python")
        self.num_pages = tk.IntVar(master, value=10)  # <-- NEW: Variable for number of pages
        self.csv_path = tk.StringVar(master, value=os.path.join(default_dir, "fiverr_data.csv"))
        self.pdf_path = tk.StringVar(master, value=os.path.join(default_dir, "market_report.pdf"))

        self.create_widgets()

    def create_widgets(self):
        main_frame = tk.Frame(self.master, padx=30, pady=30)
        main_frame.pack(fill='both', expand=True)

        # Configure Grid
        main_frame.columnconfigure(0, weight=1)
        main_frame.columnconfigure(1, weight=3)
        main_frame.columnconfigure(2, weight=1)

        # Title
        tk.Label(main_frame, text="Fiverr Market Analysis Tool", font=("Arial", 18, "bold")).grid(row=0, column=0,
                                                                                                  columnspan=3,
                                                                                                  pady=(0, 25),
                                                                                                  sticky="ew")

        # 1. Search Keyword Input (Row 1)
        tk.Label(main_frame, text="Search Keyword:").grid(row=1, column=0, padx=5, pady=5, sticky="w")
        tk.Entry(main_frame, textvariable=self.search_keyword, width=40).grid(row=1, column=1, columnspan=2, padx=5,
                                                                              pady=5, sticky="ew")

        # 1.5. Number of Pages Input (Row 2) <-- NEW FIELD
        tk.Label(main_frame, text="Pages to Scan (1-50):").grid(row=2, column=0, padx=5, pady=5, sticky="w")
        ttk.Spinbox(main_frame, from_=1, to=50, textvariable=self.num_pages, width=5).grid(row=2, column=1, padx=5,
                                                                                           pady=5, sticky="w")

        # 2. CSV Output Path (Row 3)
        tk.Label(main_frame, text="CSV Output File:").grid(row=3, column=0, padx=5, pady=5, sticky="w")
        tk.Entry(main_frame, textvariable=self.csv_path).grid(row=3, column=1, padx=5, pady=5, sticky="ew")
        tk.Button(main_frame, text="Browse", command=self.select_csv_path).grid(row=3, column=2, padx=5, pady=5,
                                                                                sticky="e")

        # 3. PDF Report Path (Row 4)
        tk.Label(main_frame, text="PDF Report File:").grid(row=4, column=0, padx=5, pady=5, sticky="w")
        tk.Entry(main_frame, textvariable=self.pdf_path).grid(row=4, column=1, padx=5, pady=5, sticky="ew")
        tk.Button(main_frame, text="Browse", command=self.select_pdf_path).grid(row=4, column=2, padx=5, pady=5,
                                                                                sticky="e")

        # 4. Start Button (Row 5)
        self.run_btn = tk.Button(main_frame, text="START ANALYSIS", command=self.start_analysis_thread,
                                 bg="#007bff", fg="white", font=("Arial", 12, "bold"))
        self.run_btn.grid(row=5, column=0, columnspan=3, pady=(20, 10), sticky="ew")

        # 5. Status Bar and Progress Bar (Rows 6 & 7)
        self.progress_bar = ttk.Progressbar(main_frame, orient='horizontal', length=500, mode='determinate',
                                            variable=self.progress_value)
        self.progress_bar.grid(row=6, column=0, columnspan=3, pady=5, sticky="ew")

        tk.Label(main_frame, textvariable=self.status_text, anchor="w", fg="#333").grid(row=7, column=0, columnspan=3,
                                                                                        sticky="w")

    # --- File Dialog Handlers ---
    def select_csv_path(self):
        filename = filedialog.asksaveasfilename(defaultextension=".csv",
                                                filetypes=[("CSV files", "*.csv")],
                                                initialfile=os.path.basename(self.csv_path.get()))
        if filename:
            self.csv_path.set(filename)

    def select_pdf_path(self):
        filename = filedialog.asksaveasfilename(defaultextension=".pdf",
                                                filetypes=[("PDF files", "*.pdf")],
                                                initialfile=os.path.basename(self.pdf_path.get()))
        if filename:
            self.pdf_path.set(filename)

    # --- Status Updater (Called by the analysis thread) ---
    def update_status(self, message, progress_percent):
        """Updates the status label and progress bar."""
        self.status_text.set(message)
        self.progress_value.set(progress_percent)
        self.master.update_idletasks()

    # --- Threading Control ---
    def start_analysis_thread(self):
        """Initiates the analysis in a separate thread to keep the GUI responsive."""
        keyword = self.search_keyword.get().strip()
        csv_file = self.csv_path.get().strip()
        pdf_file = self.pdf_path.get().strip()

        try:
            num_pages = self.num_pages.get()
        except tk.TclError:
            messagebox.showerror("Input Error", "Please enter a valid number for pages to scan.")
            return

        if not keyword:
            messagebox.showerror("Input Error", "Please enter a search keyword.")
            return

        if num_pages <= 0:
            messagebox.showerror("Input Error", "Number of pages must be at least 1.")
            return

        # Disable button and reset status
        self.run_btn.config(text="Processing...", state=tk.DISABLED, bg="#ffc107")
        self.update_status("Starting background process...", 0)

        # Start the main task function in a new thread
        self.analysis_thread = threading.Thread(
            target=self.full_analysis_workflow,
            args=(keyword, csv_file, pdf_file, num_pages),
            daemon=True
        )
        self.analysis_thread.start()

    def full_analysis_workflow(self, keyword, csv_file, pdf_file, num_pages):
        """The main sequence of operations running in the background thread."""
        success = False
        try:
            # Step 1: Run Scraping (Scraping now receives the custom NUM_PAGES)
            df = run_scraper(keyword, csv_file, self.update_status, NUM_PAGES=num_pages)

            # Step 2: Run Analysis and Plotting
            if not df.empty:
                success = run_analyzer(keyword, csv_file, pdf_file, self.update_status)
            else:
                self.update_status("Scraping failed or returned no data.", 100)

        except Exception as e:
            self.update_status(f"CRITICAL ERROR: {type(e).__name__}", 100)
            print(f"An error occurred: {e}")
            # Use self.master.after to show messagebox safely from non-main thread
            self.master.after(0, lambda: messagebox.showerror("Runtime Error",
                                                              f"A critical error occurred during the process: {e}"))

        finally:
            self.update_status("Process Complete. See output files.", 100)
            self.run_btn.config(text="START ANALYSIS", state=tk.NORMAL, bg="#007bff")
            if success:
                # Use self.master.after to show messagebox safely from non-main thread
                self.master.after(0, lambda: messagebox.showinfo("Success",
                                                                 f"Analysis Complete!\n\n"
                                                                 f"CSV Data saved to: {os.path.basename(csv_file)}\n"
                                                                 f"PDF Report saved to: {os.path.basename(pdf_file)}"))


# --- Run the Application ---
if __name__ == "__main__":
    # Ensure Tkinter initialization is only run in the main thread
    root = tk.Tk()
    app = FiverrAnalyzerApp(root)
    root.mainloop()